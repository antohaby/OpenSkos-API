<?php

/**
 * OpenSKOS
 *
 * LICENSE
 *
 * This source file is subject to the GPLv3 license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.gnu.org/licenses/gpl-3.0.txt
 *
 * @category   OpenSKOS
 * @package    OpenSKOS
 * @copyright  Copyright (c) 2015 Picturae (http://www.picturae.com)
 * @author     Picturae
 * @license    http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 */

namespace App\OpenSkos\Namespaces;

class DcTerms
{

    const NAME_SPACE = 'http://purl.org/dc/terms/';

    /**
     * exception to the rule because abstract is a reserved keyword
     */
    const DC_ABSTRACT = 'http://purl.org/dc/terms/abstract';
    const ACCESSRIGHTS = 'http://purl.org/dc/terms/accessRights';
    const ACCRUALMETHOD = 'http://purl.org/dc/terms/accrualMethod';
    const ACCRUALPERIODICITY = 'http://purl.org/dc/terms/accrualPeriodicity';
    const ACCRUALPOLICY = 'http://purl.org/dc/terms/accrualPolicy';
    const ALTERNATIVE = 'http://purl.org/dc/terms/alternative';
    const AUDIENCE = 'http://purl.org/dc/terms/audience';
    const AVAILABLE = 'http://purl.org/dc/terms/available';
    const BIBLIOGRAPHICCITATION = 'http://purl.org/dc/terms/bibliographicCitation';
    const CONFORMSTO = 'http://purl.org/dc/terms/conformsTo';
    const CONTRIBUTOR = 'http://purl.org/dc/terms/contributor';
    const COVERAGE = 'http://purl.org/dc/terms/coverage';
    const CREATED = 'http://purl.org/dc/terms/created';
    const CREATOR = 'http://purl.org/dc/terms/creator';
    const DATE = 'http://purl.org/dc/terms/date';
    const DATEACCEPTED = 'http://purl.org/dc/terms/dateAccepted';
    const DATECOPYRIGHTED = 'http://purl.org/dc/terms/dateCopyrighted';
    const DATESUBMITTED = 'http://purl.org/dc/terms/dateSubmitted';
    const DESCRIPTION = 'http://purl.org/dc/terms/description';
    const EDUCATIONLEVEL = 'http://purl.org/dc/terms/educationLevel';
    const EXTENT = 'http://purl.org/dc/terms/extent';
    const FORMAT = 'http://purl.org/dc/terms/format';
    const HASFORMAT = 'http://purl.org/dc/terms/hasFormat';
    const HASPART = 'http://purl.org/dc/terms/hasPart';
    const HASVERSION = 'http://purl.org/dc/terms/hasVersion';
    const IDENTIFIER = 'http://purl.org/dc/terms/identifier';
    const INSTRUCTIONALMETHOD = 'http://purl.org/dc/terms/instructionalMethod';
    const ISFORMATOF = 'http://purl.org/dc/terms/isFormatOf';
    const ISPARTOF = 'http://purl.org/dc/terms/isPartOf';
    const ISREFERENCEDBY = 'http://purl.org/dc/terms/isReferencedBy';
    const ISREPLACEDBY = 'http://purl.org/dc/terms/isReplacedBy';
    const ISREQUIREDBY = 'http://purl.org/dc/terms/isRequiredBy';
    const ISSUED = 'http://purl.org/dc/terms/issued';
    const ISVERSIONOF = 'http://purl.org/dc/terms/isVersionOf';
    const LANGUAGE = 'http://purl.org/dc/terms/language';
    const LICENSE = 'http://purl.org/dc/terms/license';
    const MEDIATOR = 'http://purl.org/dc/terms/mediator';
    const MEDIUM = 'http://purl.org/dc/terms/medium';
    const MODIFIED = 'http://purl.org/dc/terms/modified'; // datum
    const PROVENANCE = 'http://purl.org/dc/terms/provenance';
    const PUBLISHER = 'http://purl.org/dc/terms/publisher';
    const REFERENCES = 'http://purl.org/dc/terms/references';
    const RELATION = 'http://purl.org/dc/terms/relation';
    const REPLACES = 'http://purl.org/dc/terms/replaces';
    const REQUIRES = 'http://purl.org/dc/terms/requires';
    const RIGHTS = 'http://purl.org/dc/terms/rights';
    const RIGHTSHOLDER = 'http://purl.org/dc/terms/rightsHolder';
    const SOURCE = 'http://purl.org/dc/terms/source';
    const SPATIAL = 'http://purl.org/dc/terms/spatial';
    const SUBJECT = 'http://purl.org/dc/terms/subject';
    const TABLEOFCONTENTS = 'http://purl.org/dc/terms/tableOfContents';
    const TEMPORAL = 'http://purl.org/dc/terms/temporal';
    const TITLE = 'http://purl.org/dc/terms/title';
    const TYPE = 'http://purl.org/dc/terms/type';
    const VALID = 'http://purl.org/dc/terms/valid';

    /**
     * Gets all terms in that class.
     * @return array key => predicate
     */
    public static function getAllTerms()
    {
        $oClass = new \ReflectionClass(__CLASS__);
        $constants = $oClass->getConstants();
        unset($constants['NAME_SPACE']);

        $constants['ABSTRACT'] = $constants['DC_ABSTRACT'];
        unset($constants['DC_ABSTRACT']);

        $result = [];
        foreach ($constants as $key => $predicate) {
            $result[strtolower($key)] = $predicate;
        }

        return $result;
    }
}
